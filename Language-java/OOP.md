# OOP 객체 지향 프로그래밍 
* [01. OOP란 무엇인가?](#oop란-무엇인가)
* [02. 객체지향의 4가지 특성](#4가지-특성)
* [03. 객체지향 5대 원칙 SOLID](#객체지향-5대-원칙)
* [04. 연관 지식](#연관-지식)


## OOP란 무엇인가
    OOP : Object Oriented Programming 
    낮은 비용으로 코드의 변화가 가능해야 한다. 패러다임중 하나에 속함
    응집도가 높고, 결합도가 낮은 좋은 설계(코드의 배치)를 하기위한 패러다임
    유지보수성 + 재사용성을 위한 것! 
    
- 패러다임
    - **객체 지향**, 함수형, 리액티브
    
- 코드, 설계, 아키텍처
    - DRY, TDD, SOLID, DDD, …
    - 클린 아키텍쳐, MSA
    
- 업무 프로세스 / 문화
    - 애자일, DevOps, …





## 4가지 특성
### 추상화(Abstraction)  
    다른것도 다 중요하지만 개인적으로 가장 중요한 파트라고 생각한다. 
    객체들의 공통적인 특징(속성, 기능)을 뽑아 이름을 붙이는 것
    특정한 성질, 공통 성질(일반화)
    공통 성질을 뽑아내는 부분이 다형성과 관련있다.
    
#### 쉽게!
    추상화란 내가 물건을 배달하는 시스템을 구축한다고 해보자!
    추상화의 주 목적은 외부와의 연결이라고 생각하는데
    A업체에서 물건을 어디로 배송해주세요 라고 할때
    외부인의 입장에선 어떻게 어떤 수단을 사용해서 배달이 도착하는지는 크게 중요하지 않다. 
    빠르게 정확하게 도착하는게 중요할뿐!
    
    배달이라는 인터페이스가 
    항공기, 트럭, 기차, 오토바이등 다양한 배송수단을 제공하고 있지만 
    상세한 구현은 콘크리트 클래스 에서 구현한다.
    
    주문하는 사람 입장에선 배달이라는 인터페이스 내부가 어떻게 되는지 알 필요가 없다. 
    즉 외부입장에서 낮은 결합도를 내부에선 서로 배달을 위한 운송수단이라는 것에 대한 응집도를 가질 수 있게된다.
    인터페이스에 의존하는 코드 작성은 낮은 결합도를 얻을 수 있다

### 캡슐화(Encapsulation)
    특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶은 것 (모듈화의 의미)
    정보를 객체 안에 포함시키고, 그 정보에 대한 직접 접근은 허용하지 않는 대신, 필요에 따라 확인할 수 있는 인터페이스를 외부에 공개하는 방식

#### 캡슐화와 은닉화의 차이?
    은닉화는 외부에서 객체의 속성을 함부로 접근하지 못하도록 하는 것이다.
    캡슐화는 메서드 안에서 어떠한 일이 일어나고 있는지 모르게 해야한다는 것이다.

#### 사용이유
    캡슐화를 하게 되면 데이터를 저장, 데이터 처리, 가공, 기능 제공등이 어떻게 구현되어 있는지 
    어떻게 제공하는 지에 대한 내용은 드러내지 않는다. 

#### 접근 제어자
    public - All
    protected - 클래스, 패키지, 상속
    default - 클래스, 패키지
    private - 클래스


### 상속(Inheritance)
    상위 개념의 특징을 하위 개념이 물려받는 것
    하위 클래스 - 상위 클래스
    하위 클래스는 상위클래스 특성을 재사용하고, 확장한다.
    상위 클래스의 물려줄 특성이 많을수록 좋다
    
#### 인터페이스
    다중 상속 대신 도입
    어떤 객체가 해야할 일을 정의하는 추상 자료형
    인터 페이스는 구현을 강제할 메서드가 적을수록 좋다

### 다형성(Polymorphism)
    여러 (poly) 모습(morph)을 갖는 것  
    객체 지향에서는 한 객체가 여러 타입을 갖는 것  
    한 객체가 여러 타입의 기능을 제공   
    타입 상속으로 다형성 구현 

    다형성을 극대화 하기 위해 추상클래스나 인터페이스를 이용한다.
    
    오버라이딩
      같은 메서드 이름 / 같은 인자 목록 / 상위 클래스의 메서드 재정의
      상위 클래스 타입의 객체 참조 변수에서 자동으로 하위 클래스가 오버라이딩한 메소드를 호출해 줌

    오버로딩
      같은 메서드 이름 / 다른 인자 목록 / 다수의 메서드 중복 정의

```Java
  public class Timer {
    public void start(){ .. }
    public void stop() { .. }
  }
  public interface Rechargeable{
    void charge();
  }
```   

```Java
  public class TimerSeoul extends Timer implements Rechargeable {
   ... 
  }
  public void charge(){
   ...
  }
  TimerSeoul it = new TimerSeoul();
  it.start();
  it.stop();
  
  Timer t = it;
  t.start()
  t.stop()
  
  Rechargeable r = it;
  r.charge()
```
 


## 객체지향 5대 원칙 
    SOLID
    객체지향 (OOP)의 5대 원칙이다.

### SRP(단일책임원칙)
    한 클래스의 하나의 책임만 가져야 합니다.

### OCP(개방-폐쇄 원칙)
    확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성(Polymorphism)을 활용해야 합니다.

### LSP(리스코프 치환 원칙)
    프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다.

### ISP(인터페이스 분리 원칙)
    클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 
    특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 
    즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.

### DIP(의존관계 역전 원칙)
    추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 
    구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다.





## 연관 지식
### 응집도 (Cohesion)
    모듈에 포함된 내부 요소들이 하나의 책임/ 목적을 위해 연결되어있는 연관된 정도 입니다.
    프로그래밍 자체의 핵심으로 삼고 있는 부분중 하나
    모듈 하나가 하나의 목적과 책임으로 연결되어 있는 정도를 뜻하고.. 
    모듈 하나에 여러 역할이 있으면 그만큼 수정하기 어렵게 된다. 
    응집도가 높으면, 변경 대상과 범위가 명확해지는 장점이 있어서 코드를 수정하기 쉬워짐!

#### 특징 
    높을 수록 좋아요 ❤️ 
    응집도 (강함⬅️ ➡️약함) : 기능적, 순차적, 교환적, 절차적, 시작적(일시적), 논리적, 우연적 응집도

#### 구체적으로 어떤점이 좋을까요? 
    응집도가 높으면 수정해야될 코드가 한군데 모여있기 때문에 수정되는 부분을 파악하는데 드는 시간이 줄어듭니다
    최소한의 모듈만 분석해서 수정하면 되고 그 영향이 줄어들기 때문에 유지보수 하기 좋습니다!
    
    하나의 모듈에 수정해야될 코드가 모여있지 않으면 일단 찾기 어려워지고 서로간의 영향도를 파악하기 힘들어서 복잡해지고 
    코드 수정이 더 어려워 지는거죠..
    상관없는 코드를 다른 수정때문에 고쳐야 하는 경우가 발생하기도 하구요!


### 결합도 (Coupling)
    모듈과 모듈간의 상호 결합/의존 정도를 나타내서 결합도(Coupling)라는 이름이 붙게 되었다.
    A 모듈 수정을 위해 연관된 B 모듈의 변경을 요구하는 정도로 
    A 모듈에서 오류가 발생하여 간단한 수정 작업을 했는데 그거에 영향받아서 B모듈을 싹 뜯어 고쳐야한다면
    결합도가 매우 높은 상태가 된다.

#### 특징
    낮을 수록 좋아요 ❤️
    결합도 (약함⬅️ ➡️강함) : 자료, 스탬프, 제어, 외부, 공통, 내용 결합도

#### 구체적으로 어떤점이 좋을까요? 
    변경될 가능성이 적은 모듈은 괜찮은데 초기 모듈일 수록 변경점이 많아져서 문제가 생길 확률이 높은데
    모든 모듈은 시작부터 하는거니까 결국에 결합도는 낮추는게 좋다는 결론이...
    
    그렇지만 우리가 작성하고 설계한 코드는 버그나 회사에사의 갑작스러운 요구사항에 변경되기 쉬워서 
    어떻게 하면 모듈간 변화의 영향을 줄이고 의존성을 낮추고 재사용성을 높일 수 있을까 하는 고민을 통해..
    낮은 결합도가 낮게 유지되도록 노력해야 될 것 같습니다.

[뒤로](../README.md) / [위로](#OOP-객체-지향-프로그래밍)